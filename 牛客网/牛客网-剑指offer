牛客网解题报告
1. 合并两个排序的链表

思路：通过建立一个新的节点来链接两个链表中更小的节点

代码：
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(pHead1 == NULL)
            return pHead2;
        else if(pHead2 == NULL)
            return pHead1;
        ListNode* p = pHead1, *q = pHead2, *temp;
        if(p->val < q->val){
            temp = p;
            p = p->next;
        }else{
            temp = q;
            q = q->next;
        }
        ListNode* head = temp;
        while(p != NULL && q != NULL){
            if(p->val < q->val){
                temp->next = p;
                p = p->next;
            }else{
                temp->next = q;
                q = q->next;
            }
            temp = temp->next;
        }
        if(q != NULL){
            temp->next = q;
        }
        if(p != NULL){
            temp->next = p;
        }
        return head;
    }
};

2. 二叉树的镜像
思路： 从翻转最小的节点来递归翻转。

代码：
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
		if(pRoot == NULL)
            return ;
        Mirror(pRoot->left);
        Mirror(pRoot->right);
        TreeNode* temp = pRoot->left;
        pRoot->left = pRoot->right;
        pRoot->right = temp;
    }
};

3. 顺时针打印矩阵
思路：类似递归的思想，每次都打印最外层的数据，不断打印，结束条件是最后打印一行，或者一列，或者直接打印完

代码：
class Solution {
public:

    vector<int> printMatrix(vector<vector<int> > matrix) {
		int startX = 0, startY = 0, endX = matrix[0].size() - 1, endY = matrix.size() - 1;
        vector<int> v;
        while(1){
            if(startX == endX){
                while(startY <= endY){
                    v.push_back(matrix[startY++][startX]);
                }
                break;
            }else if(startY == endY){
                while(startX <= endX){
                    v.push_back(matrix[startY][startX++]);
                }
                break;
            }else if(startX > endX || startY > endY){
                break;
            }
			for(int i = startX; i <= endX; i++){
            	v.push_back(matrix[startY][i]);
        	}
        	for(int i = startY + 1; i <= endY; i++){
                v.push_back(matrix[i][endX]);
        	}
        	for(int i = endX - 1; i >= startX; i--){
                v.push_back(matrix[endY][i]);
        	}
        	for(int i = endY - 1; i > startY; i--){
                v.push_back(matrix[i][startX]);
        	}
            startX++;
            startY++;
            endX--;
            endY--;
        }
        return v;
    }
};
